%!TEX encoding = UTF8
%!TEX root = 0-notes.tex

\chapter{Suites, sommes, et complexités}

\section{Introduction}

\dfn{suite}{
	On appelle \emphindex{suite} une fonction $u$ réelle prenant des entiers naturels $n\in\N$.
	
	Le \emphindex{terme initial} de la suite est donné par $u_0$.
	Le \emphindex{terme de rang $n$} de la suite est donné par $u_n$.
}{dfn:suite}

\nt{
	Une suite est une liste de valeurs réelles $u_0, u_1, u_2, \dots$.
}

\nomen{
	Une suite $u$ de la forme
		\[ u_n = \big(\text{expression en fonction de $n$}\big) \]
	est donnée \emphindex{algébriquement}.
}

\ex{}{
	La suite donnée algébriquement par $u_n = n-1$ pour tout $n\in\N$ est entièrement connue.
	Son terme initial est $u_0 = -1$, et son terme de rang $210$ est $u_{210} = 209$.
}{ex:suite-alg}

\ex{}{
	Les fonctions suivantes sont des suites données par leur rang $n$ : on connait donc leur valeur pour tout les entiers naturels.
	\begin{multicols}{2}
	\begin{enumerate}
		\item $u_n = n+1$
		\item $v_n = n^2$
		\item $\xi_n = \dfrac1{n^3}$
		\item $a_n = (n+1)^n$
	\end{enumerate}
	\end{multicols}
	Une suite n'a pas forcément de formule générale pour tout $n$, c'est une simplement \emph{suite} de nombres réels.
}{}

\nt{
	Lorsque le terme de rang $n$ d'une dépend des termes de rangs inférieurs, la suite est dite \emphindex{suite récurrente}.
}

\ex{}{
	Considérons la suite $u$ définie récursivement par
		\[ \begin{cases*} u_0 = 0, \\ u_{n+1} = u_n + 2. \end{cases*} \]
	On lit « le terme de rang $n+1$ est égal au terme de rang $n$ plus 2 » ou, autrement dit, « pour passer d'un terme au suivant, il faut ajouter 2 ».
	Ainsi $u_1 = u_0 + 2 = 2, u_2 = 4, u_3= 6, \dots$.
	
	Pour calculer $u_{341}$, il faut, \emph{a priori} nécessairement calculer tous les termes de rang inférieur à $341$.
	Cependant, la forme algébrique $u_n = 2n$ pour tout $n\in\N$, et donc qu'on ait immédiatement $u_{341} = 682$.
}{ex:suite-rec}

\exe{1}{
	Calculer les 5 premiers termes de la suite
		\[ \begin{cases*} v_0 = 0, \\ v_{n+1} = v_n + 5. \end{cases*} \]
	Donner une conjecture sur sa forme algébrique.
}{exe:suite-recursive}{
	TODO
}


\section{Sommes}

\exe{,difficulty=1}{
	On considère la série statistique $X=(0;1;2;\dots;19;20)$.
	Justifier sans calcul que la moyenne de $X$ est $10$.
	En déduire que $1+2+\cdots+19+20 = 210$.
}{exe:moyenne}{
	Par symétrie autour de $10$, la moyenne de $X$ vaut $10$ : toute valeur $10+k$ se compense avec $10-k$ pour $k=1, \dots, 10$, et la valeur $10$ seule est moyenne et n'a donc aucun impact.
	
	La formule de la moyenne donne $\dfrac{1+2+\cdots+19+20}{21} = 10$, d'où le résultat.
}

\thm{}{
	Pour tout $n\in\N$, on a l'égalité	
		\[ 1 + 2 + \cdots + n = \dfrac{n(n+1)}2. \]
}{thm:triangle}

\begin{multicols}{2}
\pf{}{
	Posons $S_n = 1 + 2 + \cdots + n$ pour $n\in\N$.
	
	On considère le carré $(n+1) \times (n+1)$ ci-contre, découpé en $(n+1)^2$ carrés unités.
	
	En comptant les carrés sur chaque diagonale, on a 
		\[ S_n + (n+1) + S_n = (n+1)^2,\]
	ce qui conclut.
	\vfill\null
	
}
	\begin{center}
	\includegraphics[page=1]{figures/fig-suites.pdf}
	\end{center}
\end{multicols}

\nomen{
	On appelle $S_n$ un \emphindex{nombre triangulaire} car il apparaît comme le nombre de carrés dans le triangle de la preuve du théorème \ref{thm:triangle}.
}

\notations{
	Au lieu de noter $S_n = 1 + 2 + \cdots + n$, on dit à l'oral « la somme des entiers de 1 à $n$ », car c'est plus court.
	On dit aussi « la somme des $k$, $k$ allant de 1 à $n$ », qu'on choisit de noter
		\[ S_n = 1 + 2 + \cdots + n = \text{« la somme des $k$, $k$ allant de 1 à $n$ »} = \sum_{k=1}^n k, \]
	où la lettre sigma majuscule $\Sigma$ désigne une somme.
	
	Plus généralement, on note
		\[ \sum_{k=a}^b u_k = u_a + u_{a+1} + \cdots + u_{b-1} + u_b. \]
}

\nt{
	Il est également possible d'indexer une somme sur un ensemble.
	Par exemple pour $E=\bigset{7; 11; 13 ; 17}$, 
		\begin{align*}
			\sum_{k\in E} k = 7+11+13+17 = 48, && \text{ et } && \sum_{k\in E} \dfrac1k = \dfrac17+\dfrac1{11}+\dfrac1{13}+\dfrac1{17} \approx 0,3695.
		\end{align*}
	
	Le deuxième \emphindex{théorème de Mertens} implique que
		\[ \sum_{p \text{ premier}} \dfrac1p = \pinfty. \]
}

\exe{}{
	Donner les valeurs des sommes suivantes.
	\begin{multicols}{3}
		\begin{enumerate}[label=\roman*)]
		\item
		$\sum\limits_{k=1}^{10} 0$
		
		\item
		$\sum\limits_{k=1}^{10} 1$
		
		\item
		$\sum\limits_{k=0}^{10} 1$
		
		\item
		$\sum\limits_{k=-5}^{11} 1$
		
		\item
		$\sum\limits_{k=4}^{8} 2$
		
		\item
		$\sum\limits_{k=0}^{n} 1$
		
		\item
		$\sum\limits_{k=1}^{10} k$
		
		\item
		$\sum\limits_{k=1}^{20} k$
		
		\item
		$\sum\limits_{k=11}^{20} k$
		\end{enumerate}
	\end{multicols}
}{exe:sommes}{
	\begin{multicols}{3}
		\begin{enumerate}[label=\roman*)]
		\item
		$\sum\limits_{k=1}^{10} 0 = 0$.
		
		\item
		$\sum\limits_{k=1}^{10} 1 = 10$.
		
		\item
		$\sum\limits_{k=0}^{10} 1 = 11$.
		
		\item
		$\sum\limits_{k=-5}^{11} 1 = (11 + 5 + 1) = 17$.
		
		\item
		$\sum\limits_{k=4}^{8} 2 = 2(8-4+1) = 10$.
		
		\item
		$\sum\limits_{k=0}^{n} 1 = n$.
		
		\item
		$\sum\limits_{k=1}^{10} k = \dfrac{10(11)}2 = 55$.
		
		\item
		$\sum\limits_{k=1}^{20} k = \dfrac{20(21)}2 = 210$.
		
		\item
		$\sum\limits_{k=11}^{20} k = \sum\limits_{k=1}^{20} k - \sum\limits_{k=1}^{10} k = 210-55 = 155$.
		\end{enumerate}
	\end{multicols}
}

\exe{, difficulty=1}{
	Montrer que 
		\[ 3\sum_{k=0}^{n} v_k = \sum_{k=0}^{n} 3v_k. \]
}{exe:distr-sum}{
	TODO
}

\thm{linéarité de la somme}{
	Pour $c\in\R$ et $u, v,$ deux suites, on a 
		\[ \sum_{k=a}^{b} \bigl[ cu_k + v_k \bigr] =  c\sum_{k=a}^{b} u_k+ \sum_{k=a}^{b}v_k. \]
}{thm:linéarité-somme}

\exe{,difficulty=1}{
	Démontrer le théorème \ref{thm:linéarité-somme}.
}{exe:linéarité-somme}{
	En explicitant la somme
		\[ \sum_{k=a}^{b} \bigl[ cu(k) + v(k) \bigr] = cu(a) + v(a) + cu(a+1) + v(a+1) + \cdots + cu(b) + v(b), \]
	on remarque qu'on peut regrouper les termes et factoriser par $c$ pour obtenir
		\[ \sum_{k=a}^{b} \bigl( cu(k) + v(k) \bigr) = c\bigl[u(a) + u(a+1) + \cdots + u(b)\bigr] + \bigl[v(a) + v(a+1) + \cdots + v(b)\bigr] = c\sum_{k=a}^{b} u(k)+ \sum_{k=a}^{b}v(k). \]
}

\exe{}{
	Donner la valeur de 
		\[ \sum_{k=0}^n \bigl[ 3k + 2 \bigr]. \]
}{exe:sum-linear}{
	TODO
}

\section{Implémentation}

\nomen{
	On appelle \emph{série harmonique} la série suivante.
		\[ H_n = \sum\limits_{k=1}^n \dfrac1k = 1 + \dfrac12 + \dfrac13 + \dfrac14 + \cdots + \dfrac1n \]
}

\exe{}{
	Implémenter la série harmonique $H_n$ et donner la valeur approximative de $H_{100}$.
}{exe:serie-harmonique}{
	Voici deux implémentation de $H_n$ possibles. On obtient $H_{100} \approx 5,1873$.

	\begin{multicols}{2}
	\python{harmonic-series}
	\columnbreak
	\python{harmonic-series-2}
	\end{multicols}
}

\exe{}{
	Trouver le premier rang $n$ vérifiant $H_n \geq 10$.
}{exe:seuil-harmonique}{
	Voici une implémentation permettant de trouver le premier rang $n$ vérifiant $H_n \geq 10$. On obtient $n=12369$.
	
	\python{harmonic-series-3}
}

\dfn{précision d'un ordinateur}{
	Lorsqu'un ordinateur encode les nombres en \emphindex{virgule flottante}, sa \emphindex{précision} est finie.
	On l'appelle aussi l'\emphindex{epsilon} de la machine.
	Deux nombres à distance inférieure à cette précision sont vus comme identiques par l'ordinateur.
	
	En algorithmique moderne, les types \texttt{float} et \texttt{double} sont le plus souvent utilisés.
	\begin{itemize}
		\item La précision simple d'un \texttt{float} est de 24 bits.
		\item La précision double d'un \texttt{double} est de 53 bits.
	\end{itemize}
}{dfn:precision}

\nt{
	En python, on peut connaître l'epsilon de la machine à l'aide de la commande \texttt{sys.float\_info}.
	La notation \texttt{2.2e-16} désigne le nombre $2,2 \times 10^{-16}$.
	
	%\begin{multicols}{2}
	\python{epsilon}
	%\end{multicols}
}

\exe{, difficulty=1}{
	Justifier qu'il n'est pas possible de calculer algorithmiquement en précision finie n'importe quel terme $H_n$ de la série harmonique.
}{exe:Hn-uncomputable}{
	TODO
}


\exe{}{
	Trouver algorithmiquement le plus petit entier naturel $n\in\N$ vérifiant les inéquations suivantes.
	\begin{multicols}{2}
	\begin{enumerate}
		\item $2 \times 3^n > 100~000$
		\item $7 \times \left(\dfrac32 \right)^n > 50~000$
		\item $3 \times \left( \dfrac43 \right)^n > 1~000$
		\item $3 \times \left( \dfrac43 \right)^n > 10~000$
	\end{enumerate}
	\end{multicols}
}{exe:seuil-geom}{
	TODO
}

\section{Coût d'un algorithme : complexité en opérations et en espace}

Pour mesurer le coût des algorithmes étudiés, nous nous mettons dans le modèle RAM (pour \emph{random-access machine}).
Dans ce modèle, un ordinateur dispose : d'une mémoire infinie non ordonnée ; des opérations arithmétiques de base (addition, multiplication) ; et de certaines instructions de base (désaffectation de variable, copie, saut au sein du code, conditions).

\dfn{complexité en opérations d'un algorithme (modèle RAM)}{
	Dans le \emphindex{modèle RAM}, chaque \emphindex{opération élémentaire} est supposée prendre une même unité de temps.
	
	Les deux opérations arithmétiques élémentaires sont
	\begin{multicols}{2}
	\begin{enumerate}
		\item l'addition de deux nombres réels ; et
		\item la multiplication de deux nombres réels.
	\end{enumerate}
	\end{multicols}
}{}

\dfn{complexité en espace d'un algorithme (modèle RAM)}{
	Pour mesurer l'espace que prend un algorithme dans le modèle RAM, on compte le plus grand nombre de réels qui doivent être stockés à la fois.
	Ce nombre dépend des paramètres d'entrée de l'algorithme en question.
}{}

\nt{
	Le modèle RAM ignore la taille des nombres manipulés.
	\emph{A contrario}, le \emphindex{modèle de Turing}\footnotemark prend en compte la taille des nombres en question et est plus fidèle à la réalité. En effet, calculer $3\times7$ est plus rapide que $302194\times8491023$ !
}{}

\footnotetext{Alan Turing (1912 - 1954),  mathématicien et cryptologue britannique.}

\ex{}{
	Le calcul de $\sum_{k=1}^{n} 2$ prend $n-1$ opérations.
	Bien sûr, comme la somme est égale à $2n$, seulement une opération est nécessaire : la multiplication de $n$ par 2.
}{exe:complexité-triviale}

\nomen{
	Le terme dominant (souvent la plus grande puissance de $n$) de la complexité est appelé son \emphindex{ordre}.
	\begin{multicols}{3}
	\begin{itemize}
		\item
		L'ordre $1$ est appelé \emphindex{ordre constant} ;
		\item
		l'ordre $n$ est appelé \emphindex{ordre linéaire} ;
		\item
		l'ordre $n^2$ est appelé \emphindex{ordre quadratique} ;
		etc...
	\end{itemize}
	\end{multicols}
	
	Dans l'exemple \ref{exe:complexité-triviale}, l'ordre est d'abord linéaire, puis constant.
}

\notations{
	On note $\O(1)$ l'ordre constant, $\O(n)$ l'ordre linéaire, $\O(n^2)$ l'ordre quadratique, etc...
}

\ex{exponentiation rapide}{
	Pour calculer $5^{18}$, on a plusieurs façons de faire.
	\begin{enumerate}	
		\item Calculer toutes les puissances de $5$, de $1$ à $18$.
		On fait alors $17$ multiplications, et on garde $18$ nombres en mémoires.
		\item Calculer toutes les puissances de $5$, de $1$ à $18$, en ne gardant en mémoire que la dernière puissance.
		On fait alors $17$ multiplications, et on garde $2$ nombres en mémoire ($5$ et la dernière puissance de $5$).
		\item Calculer $5, 5^2, 5^4, 5^8, 5^{16}$ avec mises au carré successives, en ne gardant en mémoire que $5^2$ et $5^{16}$.
		Multiplier les deux résultats pour obtenir $5^{18}$.
		On fait alors $5$ multiplications, et on garde $2$ nombres en mémoire.
	\end{enumerate}
	
	La troisième façon de calculer une puissance est optimale car elle prend peu de temps et peu de mémoire.
	C'est l'\emphindex{exponentiation rapide}.
}{}

\exe{}{
	Combien d'opérations élémentaires sont nécessaires pour calculer $n^n$ ? On ne s'intéresse qu'à l'ordre.
}{exe:n-pow-n}{
	TODO
}

\exe{, difficulty=1}{
	En fonction de $n$, dire combien d'opérations élémentaires et d'espace sont nécessaires pour calculer naïvement les sommes suivantes.
	On ne s'intéressera qu'aux ordres.
		\begin{multicols}{5}
		\begin{enumerate}
			\item $\sum\limits_{k=1}^n k^2$
			\item $\sum\limits_{k=1}^n \frac1k$
			\item $\sum\limits_{k=1}^{n^2} k$
			\item $\sum\limits_{k=1}^{n} \sum\limits_{l=1}^{k} 1$
			\item $\sum\limits_{k=1}^{n} k^k$
		\end{enumerate}
		\end{multicols}
}{exe:complexité-sommes}{
	TODO
}

\exe{}{
	Utiliser le théorème \ref{thm:triangle} pour démontrer que la somme $1 + 2 + \cdots + n$ est calculable en $\O(1)$ opérations élémentaires, indépendamment de $n$.
}{exe:complexité-triangle}{
	TODO
}

\nt{
	Il s'avère qu'ajouter ou multiplier deux nombres prend un temps dépendant de leur grandeur.
	Ainsi, le temps requis pour effectuer le calcul $\frac{n(n+1)}2$ n'est pas $\O(1)$, mais $\O(\log n)$, où la fonction $\log$ sera définie au chapitre \ref{chap:log}.
	
	Intuitivement, la complexité du calcul $n+m$ dépend du nombre de chiffres qui composent $n$ et $m$ : lorsqu'on pose une addition, on ajoute les unités, puis les dizaines, puis les centaines, etc...
	Le logarithme d'un nombre donne ainsi le nombre de chiffres qui le composent.
}

\nomen{
	Une \emphindex{heuristique} est une règle pragmatique qui fonctionne la plupart du temps.
	Elle donne, par exemple, une idée de stratégie de recherche, ou d'aspect d'une solution, sans être toujours optimale, ou vraie.
}

\heur{
	Une somme d'éléments d'ordre $\O(n^k)$ est d'ordre $\O(n^{k+1})$.
	Par exemple, comme sera démontré par les exercices \ref{exe:somme-carres} et \ref{exe:somme-cubes},
		\begin{align*}
			 \sum_{k=1}^n k^2 = \O(n^3), && \et && \sum_{k=1}^n k^3 = \O(n^4).
		\end{align*}
}
